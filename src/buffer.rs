use std::{
    collections::VecDeque,
    sync::{Arc, Mutex},
};

pub struct MessageMgr {
    messages: Arc<Mutex<VecDeque<bytes::Bytes>>>,
}

#[allow(dead_code)]
impl MessageMgr {
    pub fn new() -> Self {
        MessageMgr {
            messages: Arc::new(Mutex::new(VecDeque::new())),
        }
    }

    pub fn write(&self, data: bytes::Bytes) {
        let mut queue = match self.messages.lock() {
            Ok(queue) => queue,
            Err(poisoned) => {
                tracing::warn!("found poisoned message mgr lock, returning inner");
                poisoned.into_inner()
            }
        };
        queue.push_back(data);
        let buffer_size = queue.len();
        tracing::trace!(buffer_size, "written to message buffer");
    }

    pub fn read_batch(&self, max_batch: usize) -> Vec<bytes::Bytes> {
        let mut queue = match self.messages.lock() {
            Ok(queue) => queue,
            Err(poisoned) => {
                tracing::warn!("found poisoned message mgr lock, returning inner");
                poisoned.into_inner()
            }
        };

        let will_read = std::cmp::min(max_batch, queue.len());
        let mut batch = Vec::with_capacity(will_read);

        // Actually remove messages from the queue
        for _ in 0..will_read {
            if let Some(msg) = queue.pop_front() {
                batch.push(msg);
            }
        }

        tracing::trace!(
            read_count = batch.len(),
            remaining = queue.len(),
            "read batch"
        );
        batch
    }
}

/// These are generated by Claude.
#[cfg(test)]
mod tests {
    use super::*;
    use bytes::Bytes;
    use std::sync::Arc;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_new_creates_empty_manager() {
        let mgr = MessageMgr::new();
        let batch = mgr.read_batch(10);
        assert!(batch.is_empty());
    }

    #[test]
    fn test_write_single_message() {
        let mgr = MessageMgr::new();
        let data = Bytes::from("hello world");

        mgr.write(data.clone());
        let batch = mgr.read_batch(1);

        assert_eq!(batch.len(), 1);
        assert_eq!(batch[0], data);
    }

    #[test]
    fn test_write_multiple_messages() {
        let mgr = MessageMgr::new();
        let messages = vec![
            Bytes::from("message1"),
            Bytes::from("message2"),
            Bytes::from("message3"),
        ];

        for msg in &messages {
            mgr.write(msg.clone());
        }

        let batch = mgr.read_batch(10);
        assert_eq!(batch.len(), 3);
        assert_eq!(batch, messages);
    }

    #[test]
    fn test_read_batch_respects_max_limit() {
        let mgr = MessageMgr::new();

        for i in 0..5 {
            mgr.write(Bytes::from(format!("message{}", i)));
        }

        let batch = mgr.read_batch(3);
        assert_eq!(batch.len(), 3);

        assert_eq!(batch[0], Bytes::from("message0"));
        assert_eq!(batch[1], Bytes::from("message1"));
        assert_eq!(batch[2], Bytes::from("message2"));

        let remaining = mgr.read_batch(10);
        assert_eq!(remaining.len(), 2);
        assert_eq!(remaining[0], Bytes::from("message3"));
        assert_eq!(remaining[1], Bytes::from("message4"));
    }

    #[test]
    fn test_read_batch_empty_queue() {
        let mgr = MessageMgr::new();
        let batch = mgr.read_batch(5);
        assert!(batch.is_empty());
    }

    #[test]
    fn test_read_batch_zero_max() {
        let mgr = MessageMgr::new();
        mgr.write(Bytes::from("test"));

        let batch = mgr.read_batch(0);
        assert!(batch.is_empty());

        let remaining = mgr.read_batch(1);
        assert_eq!(remaining.len(), 1);
    }

    #[test]
    fn test_fifo_ordering() {
        let mgr = MessageMgr::new();
        let expected_order = vec![
            Bytes::from("first"),
            Bytes::from("second"),
            Bytes::from("third"),
            Bytes::from("fourth"),
        ];

        for msg in &expected_order {
            mgr.write(msg.clone());
        }

        for expected_msg in &expected_order {
            let batch = mgr.read_batch(1);
            assert_eq!(batch.len(), 1);
            assert_eq!(&batch[0], expected_msg);
        }

        let empty_batch = mgr.read_batch(1);
        assert!(empty_batch.is_empty());
    }

    #[test]
    fn test_messages_are_consumed() {
        let mgr = MessageMgr::new();
        mgr.write(Bytes::from("consume me"));

        let batch1 = mgr.read_batch(1);
        assert_eq!(batch1.len(), 1);

        let batch2 = mgr.read_batch(1);
        assert!(batch2.is_empty());
    }

    #[test]
    fn test_concurrent_writers() {
        let mgr = Arc::new(MessageMgr::new());
        let num_threads = 4;
        let messages_per_thread = 100;

        let handles: Vec<_> = (0..num_threads)
            .map(|thread_id| {
                let mgr_clone = Arc::clone(&mgr);
                thread::spawn(move || {
                    for i in 0..messages_per_thread {
                        let data = Bytes::from(format!("thread{}-msg{}", thread_id, i));
                        mgr_clone.write(data);
                    }
                })
            })
            .collect();

        for handle in handles {
            handle.join().unwrap();
        }

        let mut all_messages = Vec::new();
        loop {
            let batch = mgr.read_batch(50);
            if batch.is_empty() {
                break;
            }
            all_messages.extend(batch);
        }

        assert_eq!(all_messages.len(), num_threads * messages_per_thread);
    }

    #[test]
    fn test_concurrent_readers() {
        let mgr = Arc::new(MessageMgr::new());

        for i in 0..1000 {
            mgr.write(Bytes::from(format!("message{}", i)));
        }

        let num_readers = 4;
        let handles: Vec<_> = (0..num_readers)
            .map(|_| {
                let mgr_clone = Arc::clone(&mgr);
                thread::spawn(move || {
                    let mut total_read = 0;
                    loop {
                        let batch = mgr_clone.read_batch(10);
                        if batch.is_empty() {
                            break;
                        }
                        total_read += batch.len();
                    }
                    total_read
                })
            })
            .collect();

        let mut total_messages_read = 0;
        for handle in handles {
            total_messages_read += handle.join().unwrap();
        }

        assert_eq!(total_messages_read, 1000);

        let remaining = mgr.read_batch(1);
        assert!(remaining.is_empty());
    }

    #[test]
    fn test_concurrent_writers_and_readers() {
        let mgr = Arc::new(MessageMgr::new());
        let total_messages = 1000;

        let writer_mgr = Arc::clone(&mgr);
        let writer_handle = thread::spawn(move || {
            for i in 0..total_messages {
                writer_mgr.write(Bytes::from(format!("msg{}", i)));
                if i % 100 == 0 {
                    thread::sleep(Duration::from_millis(1));
                }
            }
        });

        let num_readers = 3;
        let reader_handles: Vec<_> = (0..num_readers)
            .map(|_| {
                let mgr_clone = Arc::clone(&mgr);
                thread::spawn(move || {
                    let mut messages_read = Vec::new();
                    let mut empty_reads = 0;
                    while empty_reads < 10 {
                        let batch = mgr_clone.read_batch(5);
                        if batch.is_empty() {
                            empty_reads += 1;
                            thread::sleep(Duration::from_millis(1));
                        } else {
                            empty_reads = 0;
                            messages_read.extend(batch);
                        }
                    }
                    messages_read
                })
            })
            .collect();

        writer_handle.join().unwrap();

        let mut all_read_messages = Vec::new();
        for handle in reader_handles {
            all_read_messages.extend(handle.join().unwrap());
        }

        assert_eq!(all_read_messages.len(), total_messages);
    }

    #[test]
    fn test_large_messages() {
        let mgr = MessageMgr::new();

        let large_data = vec![0u8; 1024 * 1024];
        let large_message = Bytes::from(large_data);

        mgr.write(large_message.clone());

        let batch = mgr.read_batch(1);
        assert_eq!(batch.len(), 1);
        assert_eq!(batch[0], large_message);
        assert_eq!(batch[0].len(), 1024 * 1024);
    }

    #[test]
    fn test_empty_messages() {
        let mgr = MessageMgr::new();

        let empty_msg = Bytes::new();
        mgr.write(empty_msg.clone());

        let batch = mgr.read_batch(1);
        assert_eq!(batch.len(), 1);
        assert_eq!(batch[0], empty_msg);
        assert!(batch[0].is_empty());
    }

    #[test]
    fn test_alternating_write_read() {
        let mgr = MessageMgr::new();

        for i in 0..10 {
            let msg = Bytes::from(format!("message{}", i));
            mgr.write(msg.clone());

            let batch = mgr.read_batch(1);
            assert_eq!(batch.len(), 1);
            assert_eq!(batch[0], msg);
        }

        let empty_batch = mgr.read_batch(1);
        assert!(empty_batch.is_empty());
    }

    #[test]
    fn test_stress_many_small_messages() {
        let mgr = MessageMgr::new();
        let num_messages = 10000;

        for i in 0..num_messages {
            mgr.write(Bytes::from(i.to_string()));
        }

        let mut total_read = 0;
        let mut batch_count = 0;

        while total_read < num_messages {
            let batch = mgr.read_batch(100);
            if batch.is_empty() {
                break;
            }
            total_read += batch.len();
            batch_count += 1;
        }

        assert_eq!(total_read, num_messages);
        assert!(batch_count <= (num_messages / 100) + 1);
    }

    #[test]
    fn test_message_independence() {
        let mgr = MessageMgr::new();

        let msg1 = Bytes::from("message1");
        let msg2 = Bytes::from("message2");

        mgr.write(msg1.clone());
        mgr.write(msg2.clone());

        let batch1 = mgr.read_batch(1);
        assert_eq!(batch1[0], msg1);

        let batch2 = mgr.read_batch(1);
        assert_eq!(batch2[0], msg2);

        assert_ne!(batch1[0], batch2[0]);
    }

    #[test]
    fn test_batch_size_larger_than_available() {
        let mgr = MessageMgr::new();

        mgr.write(Bytes::from("only message"));

        let batch = mgr.read_batch(100);
        assert_eq!(batch.len(), 1);
    }

    #[test]
    fn test_multiple_batch_reads() {
        let mgr = MessageMgr::new();

        for i in 0..10 {
            mgr.write(Bytes::from(format!("msg{}", i)));
        }

        let batch1 = mgr.read_batch(3);
        let batch2 = mgr.read_batch(4);
        let batch3 = mgr.read_batch(10);

        assert_eq!(batch1.len(), 3);
        assert_eq!(batch2.len(), 4);
        assert_eq!(batch3.len(), 3);

        assert_eq!(batch1[0], Bytes::from("msg0"));
        assert_eq!(batch2[0], Bytes::from("msg3"));
        assert_eq!(batch3[0], Bytes::from("msg7"));
    }
}
